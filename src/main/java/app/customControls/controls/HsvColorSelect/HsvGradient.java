package app.customControls.controls.HsvColorSelect;

import app.customControls.utilities.ArrayUtil;
import app.customControls.utilities.ColorUtil;
import app.customControls.utilities.ScreenUtil;
import javafx.beans.InvalidationListener;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.value.ChangeListener;

import java.util.Arrays;

/**
 * Data structure representing a procedurally generated hsv spectrum gradient.<br><br>
 * Optimisations have been made so that only new values are generated whilst old values are kept in memory.
 * This means that once the entire spectrum has been generated by the user, no more calculations are necessary
 * and only old values will be re-used.
 *
 * @implNote Keep in mind that for the moment the bottleneck is drawing the pixels to a
 * {@link javafx.scene.canvas.Canvas Canvas}, not generating their values
 *
 * @see HsvColorSelect
 */
public class HsvGradient {

    // ===================================
    //               FIELDS
    // ===================================

    /*           DEFAULT VALUES         */
    private static final int DEFAULT_HUE        = 0;
    private static final int DEFAULT_SATURATION = 100;
    private static final int DEFAULT_VALUE      = 100;
    private static final int SEXTANT_SIZE       = 60;

    /*          GRADIENT VALUES         */
    // private final int[][] sextants              = new int[6][];
    private        final Integer[][] sextants    = new Integer[6][];
    private        final int[][] generatedValues = new int[6][];

    /*             PROPERTIES           */
    private        final SimpleIntegerProperty hue;
    private        final SimpleIntegerProperty saturation;
    private        final SimpleIntegerProperty value;

    public         final SimpleIntegerProperty width;
    public         final SimpleIntegerProperty height;

    /*             LISTENERS            */
    private        final ChangeListener<Number> resetOnResize;
    private        final InvalidationListener generateOnCHange;

    // ===================================
    //            CONSTRUCTOR
    // ===================================

    public HsvGradient(final int width, final int height) {
        this(width, height, DEFAULT_HUE, DEFAULT_SATURATION, DEFAULT_VALUE);
    }

    public HsvGradient(final int width, final int height, final int hue, final int saturation, final int value) {

        this.hue                    = new SimpleIntegerProperty(hue);
        this.saturation             = new SimpleIntegerProperty(saturation);
        this.value                  = new SimpleIntegerProperty(value);

        setHue(hue);
        setSaturation(saturation);
        setValue(value);

        this.width                  = new SimpleIntegerProperty(width);
        this.height                 = new SimpleIntegerProperty(height);

        setWidth(width);
        setHeight(height);

        this.resetOnResize          = (observableValue, oldValue, newValue) -> reset();
        this.generateOnCHange       = observable                            -> generateGradient();

        registerListeners();

        reset();
        generateGradient();

    }

    // ===================================
    //            LISTENERS
    // ===================================

    private void registerListeners() {
        // resizing
        widthProperty()     .addListener(resetOnResize);
        heightProperty()    .addListener(resetOnResize);

        // value changes
        hueProperty()       .addListener(generateOnCHange);
        saturationProperty().addListener(generateOnCHange);
        valueProperty()     .addListener(generateOnCHange);
    }

    private void reset() {
        for (int i = 0; i < sextants.length; i++) {
            sextants[i] = new Integer[getSize()];
        }

        for (int i = 0; i < generatedValues.length; i++) {
            generatedValues[i] = new int[getWidth()];
        }

        generateGradient();
    }

    // ===================================
    //            GENERATION
    // ===================================

    private void generateGradient() {
        // determines the current sextant & the current position along the hue spectrum
        final int startingSextant       = ColorUtil.Hsv.getSextant(getHue());
        final int startingPosition      = hueToPixel(getHue());

        // generates all columns which have not yet been generated
        for (int i = 0; i < getWidth(); i++) {
            if (!hasGenerated(startingSextant, hueToPixel(getHue()), i)) {
                generate(startingPosition, i);
            }
        }
    }

    private boolean hasGenerated(final int startingSextant, final int startingPosition, final int currentPosition) {
        // determines the current sextant
        final int currentX       = (startingPosition + currentPosition) % (360 * getWidth());
        final int localX         = currentX % getWidth();
        final int currentSextant = (startingSextant + (currentX / getWidth())) % 6;

        // System.out.printf("x:%s, sextant:%s\n", localX, currentSextant);
        // System.out.println(Arrays.toString(generatedValues[currentSextant]));

        // checks if the column corresponding to the specified hue has already been generated
        return generatedValues[currentSextant][localX] == getValue();
    }

    private void markGenerated(final int currenSextant, final int currentPosition) {
        generatedValues[currenSextant][currentPosition] = getValue();
    }

    private void generate(final int startingPosition, final int currentPosition) {

        // determines the hue at the current pixel
        final double hue            = pixelToHue(currentPosition);

        // determines the position in the current sextant
        final int localPosition  = (currentPosition + startingPosition) % getWidth();

        // determines the current sextant
        final int currentSextant    = (int) hue / SEXTANT_SIZE % 6;
        // System.out.printf("x:%s, hue:%s, sextant:%s\n", localPosition, hue, currentSextant);

        // marks the columns as generated
        markGenerated(currentSextant, localPosition);

        // generates the gradient from top to bottom
        final int startValue        = getHeight() - 1;
        for (int y = startValue; y >= 0 ; y--) {

            final double saturation = s(y);
            final int color         = ColorUtil.Hsv.toArgbCode(hue, saturation, getValue());


            // saves the result
            saveHsv(currentSextant, localPosition, startValue - y, color);
        }

    }

    private void saveHsv(final int currentSextant, final int x, final int y, final int rgbValue) {
        // System.out.printf("x: %s, y: %s, sextant:%s\n", x, y, currentSextant);
        ArrayUtil.setValueAt(sextants[currentSextant], getWidth(), getHeight(), x, y, rgbValue);
    }

    private double s(final int y) {
        final double deltaSaturation    = 100.0 / (getHeight() - 1);

        // saturation at the current height
        return y * deltaSaturation;
    }

    // ===================================
    //            CONVERSION
    // ===================================

    private double pixelToHue(final int pixel) {
        return (getHue() + pixel * (double) SEXTANT_SIZE / getWidth()) % 360;
    }

    private int hueToPixel(final double hue) {
        final double adjustedHue = hue % SEXTANT_SIZE;
        return (int) adjustedHue * getWidth() / SEXTANT_SIZE;
    }

    // ===================================
    //             ACCESSORS
    // ===================================

    // getting current view
    public int[] sliceOf(final int startHue) {

        final Integer[] slice       = new Integer[getSize()];

        final int endHue            = startHue + SEXTANT_SIZE;

        final int startSextant      = ColorUtil.Hsv.getSextant(startHue);
        final int endSextant        = ColorUtil.Hsv.getSextant(endHue);

        final int startPixel        = hueToPixel(startHue);
        final int endPixel          = hueToPixel(endHue);

        // if all values are contained in one sextant, returns that sextant
        if (startSextant == endSextant) {

            final Integer[] currentArray = sextants[startSextant];
            final int[] intArray         = Arrays.stream(currentArray).mapToInt(i -> i).toArray();

            return intArray;
        }

        // hue coordinates of the change in sextants
        final int pixelDelta        = getWidth() - startPixel;
        final int availableHeight   = (getHeight() - 1);

        // gets color codes from the first sextant
        final Integer[] firstSextant = sextants[startSextant];

        for (int x = startPixel; x < getWidth(); x++) {

            for (int y = availableHeight; y >= 0; y--) {

                // adjusts the height at which to get the color
                final int adjustY   = availableHeight - y;

                // gets the color in the first sextant...
                final int color     = ArrayUtil.valueAt(
                        firstSextant, getWidth(), getHeight(), x, adjustY);
                // ...and saves in the combined array
                ArrayUtil.setValueAt(slice, getWidth(), getHeight(), x - startPixel, adjustY, color);

            }
        }

        // gets the color codes from the second sextant
        final Integer[] secondSextant = sextants[endSextant];

        for (int x = 0; x < endPixel; x++) {

            for (int y = availableHeight; y >= 0; y--) {

                // adjusts the height at which to get the color
                final int adjustY   = availableHeight - y;

                // gets the color in the first sextant
                final int color     = ArrayUtil.valueAt(
                        secondSextant, getWidth(), getHeight(), x, adjustY
                );

                // and saves it to the combined array
                ArrayUtil.setValueAt(slice, getWidth(), getHeight(), x + pixelDelta, adjustY, color);
            }

        }

        // converts the array to int[] format
        final int[] intArray = Arrays.stream(slice).mapToInt(i -> i).toArray();

        // returns the combined array
        return intArray;
    }

    // pixel values
    /**
     * Gets the RGB code of the pixel at the specified position in the HSV gradient
     * @param x (int): x-coordinates of the pixel
     * @param y (int): y-coordinates of the pixel
     * @param h (int): hue used to locate pixel
     * @return (int): RGB code of the pixel at the specified coordinates
     */
    public int pixelAt(final int x, final int y, final int h) {
        // determines which sextant the pixel belongs is
        final int i = ColorUtil.Hsv.getSextant(h);
        // gets the pixel from the current sextant
        // return ArrayUtil.valueAt(sextants[i], getWidth(), getHeight(), x, y);
        // TODO: get this working again
        return 0;
    }

    // width
    public IntegerProperty widthProperty() {
        return width;
    }

    public int getWidth() {
        return width.get();
    }

    public void setWidth(final int newWidth) {
        if (newWidth  < 0 || newWidth > ScreenUtil.getScreenWidth()) return;
        width.set(newWidth);
    }

    // height
    public IntegerProperty heightProperty() {
        return height;
    }

    public int getHeight() {
        return height.get();
    }

    public void setHeight(final int newHeight) {
        if (newHeight < 0 || newHeight > ScreenUtil.getScreenHeight()) return;
        height.set(newHeight);
    }

    // size
    public int getSize() {
        return getWidth() * getHeight();
    }

    // hue
    public IntegerProperty hueProperty() {
        return hue;
    }

    public int getHue() {
        return hue.get();
    }

    public void setHue(final int newHue) {
        if (newHue < 0 || newHue > 360) return;
        hue.set(newHue);
    }

    // saturation
    public IntegerProperty saturationProperty() {
        return saturation;
    }

    public int getSaturation() {
        return saturation.get();
    }

    public void setSaturation(final int newSaturation) {
        if (newSaturation < 0 || newSaturation > 100) return;
        saturation.set(newSaturation);
    }

    // value
    public IntegerProperty valueProperty() {
        return value;
    }

    public int getValue() {
        return value.get();
    }

    public void setValue(final int newValue) {
        if (newValue < 0 || newValue > 100) return;
        value.set(newValue);
    }

    // ===================================
    //               DEBUG
    // ===================================

    public void displayInConsole(final int[] currentSextant) {

        for (int i = 0; i < currentSextant.length; i++) {

            if (i % getWidth() == 0) System.out.println("\n");
            System.out.print(currentSextant[i] + " ");

        }

    }
}
